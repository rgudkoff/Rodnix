/**
 * @file cpu.h
 * @brief Архитектурно-независимый интерфейс для работы с процессором
 * 
 * Определяет абстракции для работы с процессором, которые
 * реализуются в архитектурно-зависимых модулях.
 */

#ifndef _RODNIX_CORE_CPU_H
#define _RODNIX_CORE_CPU_H

#include "arch_types.h"
#include <stdint.h>
#include <stdbool.h>

/* ============================================================================
 * Информация о процессоре
 * ============================================================================ */

typedef struct {
    uint32_t cpu_id;           /* ID процессора */
    uint32_t apic_id;          /* APIC ID (x86) или аналогичный */
    const char* vendor;        /* Производитель (Intel, AMD, ARM, etc.) */
    const char* model;         /* Модель процессора */
    uint32_t features;         /* Архитектурные особенности */
    uint32_t cores;            /* Количество ядер */
    uint32_t threads;          /* Количество потоков */
} cpu_info_t;

/* ============================================================================
 * Инициализация
 * ============================================================================ */

/**
 * Инициализация подсистемы процессоров
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int cpu_init(void);

/**
 * Получение информации о текущем процессоре
 * @param info Указатель на структуру для заполнения
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int cpu_get_info(cpu_info_t* info);

/**
 * Получение ID текущего процессора
 * @return ID процессора
 */
uint32_t cpu_get_id(void);

/**
 * Получение количества процессоров
 * @return Количество процессоров в системе
 */
uint32_t cpu_get_count(void);

/* ============================================================================
 * Переключение контекста
 * ============================================================================ */

typedef struct thread_context {
    void* arch_specific;       /* Архитектурно-зависимые данные */
    uint64_t stack_pointer;    /* Указатель стека */
    uint64_t program_counter;  /* Счетчик команд */
} thread_context_t;

/**
 * Сохранение контекста текущего потока
 * @param ctx Указатель на структуру для сохранения контекста
 */
void cpu_save_context(thread_context_t* ctx);

/**
 * Восстановление контекста потока
 * @param ctx Указатель на структуру с контекстом
 */
void cpu_restore_context(thread_context_t* ctx);

/**
 * Переключение на другой поток
 * @param from Контекст текущего потока
 * @param to Контекст нового потока
 */
void cpu_switch_thread(thread_context_t* from, thread_context_t* to);

/* ============================================================================
 * Барьеры памяти
 * ============================================================================ */

/**
 * Полный барьер памяти (memory fence)
 * Гарантирует, что все операции до барьера завершатся до операций после
 */
void cpu_memory_barrier(void);

/**
 * Барьер чтения (load fence)
 * Гарантирует, что все чтения до барьера завершатся до чтений после
 */
void cpu_read_barrier(void);

/**
 * Барьер записи (store fence)
 * Гарантирует, что все записи до барьера завершатся до записей после
 */
void cpu_write_barrier(void);

/* ============================================================================
 * Атомарные операции
 * ============================================================================ */

/**
 * Атомарное сложение
 * @param ptr Указатель на значение
 * @param value Значение для сложения
 * @return Новое значение после сложения
 */
uint64_t cpu_atomic_add(volatile uint64_t* ptr, uint64_t value);

/**
 * Атомарное вычитание
 * @param ptr Указатель на значение
 * @param value Значение для вычитания
 * @return Новое значение после вычитания
 */
uint64_t cpu_atomic_sub(volatile uint64_t* ptr, uint64_t value);

/**
 * Атомарное логическое И
 * @param ptr Указатель на значение
 * @param value Значение для операции И
 * @return Новое значение после операции
 */
uint64_t cpu_atomic_and(volatile uint64_t* ptr, uint64_t value);

/**
 * Атомарное логическое ИЛИ
 * @param ptr Указатель на значение
 * @param value Значение для операции ИЛИ
 * @return Новое значение после операции
 */
uint64_t cpu_atomic_or(volatile uint64_t* ptr, uint64_t value);

/**
 * Атомарное логическое исключающее ИЛИ
 * @param ptr Указатель на значение
 * @param value Значение для операции XOR
 * @return Новое значение после операции
 */
uint64_t cpu_atomic_xor(volatile uint64_t* ptr, uint64_t value);

/**
 * Атомарная замена значения
 * @param ptr Указатель на значение
 * @param new_value Новое значение
 * @return Старое значение
 */
uint64_t cpu_atomic_swap(volatile uint64_t* ptr, uint64_t new_value);

/**
 * Атомарное сравнение и замена (CAS)
 * @param ptr Указатель на значение
 * @param expected Ожидаемое значение
 * @param new_value Новое значение
 * @return Старое значение (если было равно expected, иначе старое значение)
 */
uint64_t cpu_atomic_compare_and_swap(volatile uint64_t* ptr, uint64_t expected, uint64_t new_value);

/* ============================================================================
 * Утилиты процессора
 * ============================================================================ */

/**
 * Пауза процессора (для спинлоков)
 * Уменьшает энергопотребление в цикле ожидания
 */
void cpu_pause(void);

/**
 * Ожидание процессора (HLT или аналогичная инструкция)
 * Переводит процессор в режим ожидания прерывания
 */
void cpu_idle(void);

/**
 * Получение тактовой частоты процессора
 * @return Частота в Гц или 0 если неизвестна
 */
uint64_t cpu_get_frequency(void);

/**
 * Получение времени (TSC или аналогичный)
 * @return Значение счетчика времени процессора
 */
uint64_t cpu_get_time(void);

#endif /* _RODNIX_CORE_CPU_H */

