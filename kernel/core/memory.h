/**
 * @file memory.h
 * @brief Архитектурно-независимый интерфейс для управления памятью
 * 
 * Определяет абстракции для работы с памятью, которые
 * реализуются в архитектурно-зависимых модулях.
 */

#ifndef _RODNIX_CORE_MEMORY_H
#define _RODNIX_CORE_MEMORY_H

#include "arch_types.h"
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/* ============================================================================
 * Флаги страницы
 * ============================================================================ */

#define PAGE_FLAG_PRESENT   (1UL << 0)  /* Страница присутствует */
#define PAGE_FLAG_WRITABLE  (1UL << 1)  /* Страница доступна для записи */
#define PAGE_FLAG_USER      (1UL << 2)  /* Страница доступна пользователю */
#define PAGE_FLAG_EXECUTE   (1UL << 3)  /* Страница исполняемая */
#define PAGE_FLAG_NOCACHE   (1UL << 4)  /* Без кэширования */
#define PAGE_FLAG_WRITETHROUGH (1UL << 5) /* Write-through кэш */
#define PAGE_FLAG_GLOBAL    (1UL << 6)  /* Глобальная страница (TLB) */

/* ============================================================================
 * Тип страницы
 * ============================================================================ */

typedef enum {
    PAGE_TYPE_4KB = 0,     /* 4KB страница */
    PAGE_TYPE_2MB,        /* 2MB страница (large page) */
    PAGE_TYPE_1GB,        /* 1GB страница (huge page) */
} page_type_t;

/* ============================================================================
 * Дескриптор страницы
 * ============================================================================ */

typedef struct {
    uint64_t virt_addr;    /* Виртуальный адрес */
    uint64_t phys_addr;    /* Физический адрес */
    uint64_t flags;        /* Флаги страницы */
    page_type_t type;      /* Тип страницы */
} page_desc_t;

/* ============================================================================
 * Инициализация
 * ============================================================================ */

/**
 * Инициализация подсистемы памяти
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int memory_init(void);

/**
 * Инициализация пейджинга
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int paging_init(void);

/* ============================================================================
 * Управление страницами
 * ============================================================================ */

/**
 * Отображение страницы
 * @param virt Виртуальный адрес
 * @param phys Физический адрес
 * @param flags Флаги страницы
 * @param type Тип страницы
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int page_map(uint64_t virt, uint64_t phys, uint64_t flags, page_type_t type);

/**
 * Удаление отображения страницы
 * @param virt Виртуальный адрес
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int page_unmap(uint64_t virt);

/**
 * Получение физического адреса по виртуальному
 * @param virt Виртуальный адрес
 * @return Физический адрес или 0 при ошибке
 */
uint64_t page_get_physical(uint64_t virt);

/**
 * Получение виртуального адреса по физическому (если есть identity mapping)
 * @param phys Физический адрес
 * @return Виртуальный адрес или 0 при ошибке
 */
uint64_t page_get_virtual(uint64_t phys);

/* ============================================================================
 * Физическая память (PMM)
 * ============================================================================ */

/**
 * Выделение физической страницы
 * @return Физический адрес страницы или 0 при ошибке
 */
uint64_t pmm_alloc_page(void);

/**
 * Освобождение физической страницы
 * @param phys Физический адрес страницы
 */
void pmm_free_page(uint64_t phys);

/**
 * Выделение нескольких физических страниц
 * @param count Количество страниц
 * @return Физический адрес первой страницы или 0 при ошибке
 */
uint64_t pmm_alloc_pages(uint32_t count);

/**
 * Освобождение нескольких физических страниц
 * @param phys Физический адрес первой страницы
 * @param count Количество страниц
 */
void pmm_free_pages(uint64_t phys, uint32_t count);

/* ============================================================================
 * Виртуальная память (VMM)
 * ============================================================================ */

/**
 * Выделение виртуальной страницы
 * @param flags Флаги страницы
 * @return Виртуальный адрес страницы или NULL при ошибке
 */
void* vmm_alloc_page(uint64_t flags);

/**
 * Освобождение виртуальной страницы
 * @param virt Виртуальный адрес страницы
 */
void vmm_free_page(void* virt);

/**
 * Выделение нескольких виртуальных страниц
 * @param count Количество страниц
 * @param flags Флаги страниц
 * @return Виртуальный адрес первой страницы или NULL при ошибке
 */
void* vmm_alloc_pages(uint32_t count, uint64_t flags);

/**
 * Освобождение нескольких виртуальных страниц
 * @param virt Виртуальный адрес первой страницы
 * @param count Количество страниц
 */
void vmm_free_pages(void* virt, uint32_t count);

/* ============================================================================
 * Информация о памяти
 * ============================================================================ */

typedef struct {
    uint64_t total_physical;  /* Общая физическая память */
    uint64_t free_physical;   /* Свободная физическая память */
    uint64_t used_physical;   /* Используемая физическая память */
    uint64_t total_virtual;   /* Общая виртуальная память */
    uint64_t free_virtual;    /* Свободная виртуальная память */
    uint64_t used_virtual;    /* Используемая виртуальная память */
} memory_info_t;

/**
 * Получение информации о памяти
 * @param info Указатель на структуру для заполнения
 * @return 0 при успехе, отрицательное значение при ошибке
 */
int memory_get_info(memory_info_t* info);

/* ============================================================================
 * Макросы для преобразования адресов
 * ============================================================================ */

#define VIRT_TO_PHYS(addr) page_get_physical((uint64_t)(addr))
#define PHYS_TO_VIRT(addr) ((void*)page_get_virtual((uint64_t)(addr)))

#endif /* _RODNIX_CORE_MEMORY_H */

